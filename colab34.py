# -*- coding: utf-8 -*-
"""Untitled34.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GX96WRWRIPi9sXsW_tm_HO6yfB7iBxXH
"""

import numpy as np
import pandas as pd

# Function for the differential equation
def population_growth(P, r, K):
    return r * P * (1 - P / K)

# Euler method
def euler_method(P0, r, K, h, t_end):
    t = 0
    P = P0
    result = []
    while t <= t_end:
        result.append((t, P))
        P = P + h * population_growth(P, r, K)
        t += h
    return result

# Heun's method (Improved Euler method)
def heuns_method(P0, r, K, h, t_end):
    t = 0
    P = P0
    result = []
    while t <= t_end:
        result.append((t, P))
        k1 = population_growth(P, r, K)
        k2 = population_growth(P + h * k1, r, K)
        P = P + h * (k1 + k2) / 2
        t += h
    return result

# RK4 method
def rk4_method(P0, r, K, h, t_end):
    t = 0
    P = P0
    result = []
    while t <= t_end:
        result.append((t, P))
        k1 = h * population_growth(P, r, K)
        k2 = h * population_growth(P + 0.5 * k1, r, K)
        k3 = h * population_growth(P + 0.5 * k2, r, K)
        k4 = h * population_growth(P + k3, r, K)
        P = P + (k1 + 2*k2 + 2*k3 + k4) / 6
        t += h
    return result

# Exact solution
def exact_solution(t, r, K):
    return 3000 * np.exp(r * t) / (1 + 1.5 * np.exp(r * t))

# Initial conditions and parameters
P0 = 1200
r = 0.06
K = 2000
t_end = 30
step_sizes = [10, 1, 0.1]

# Methods and their corresponding functions
methods = {
    'Euler': euler_method,
    'Heun': heuns_method,
    'RK4': rk4_method
}

# Exact value at t = 30
exact_value = exact_solution(30, r, K)

# Create a dataframe to store errors
errors = pd.DataFrame(columns=["Method", "Step Size", "Approx Value", "Exact Value", "Absolute Error"])

# Compute errors for each method and step size
for method_name, method_func in methods.items():
    for h in step_sizes:
        result = method_func(P0, r, K, h, t_end)
        approx_value = result[-1][1]
        abs_error = abs(approx_value - exact_value)
        errors = errors.append({
            "Method": method_name,
            "Step Size": h,
            "Approx Value": approx_value,
            "Exact Value": exact_value,
            "Absolute Error": abs_error
        }, ignore_index=True)

# Display errors
import ace_tools as tools; tools.display_dataframe_to_user(name="Errors in Numerical Methods", dataframe=errors)

# Find the most accurate method
most_accurate = errors.loc[errors["Absolute Error"].idxmin()]
print("Most accurate method:", most_accurate)
