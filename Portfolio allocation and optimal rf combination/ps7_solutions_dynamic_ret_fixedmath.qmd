---
title: "MGMTMFE 400 — Problem Set 7"
author: "Tiffany Tu"
format:
  pdf:
    toc: false
    number-sections: true
execute:
  echo: true
  warning: false
  message: false
---

## 0. Setup

```{r}
# Core packages
library(readr)
library(dplyr)
library(lubridate)
library(tidyr)
library(ggplot2)
library(purrr)
library(tibble)

TRADING_DAYS <- 252
WEEKS_PER_YEAR <- 52
```

## 0.1 Load data

```{r}
# ===== S&P 500 daily total return data =====
# File: 500csv.csv, columns: caldt (m/d/Y), vwretd
sp <- read_csv("500csv.csv", col_types = cols())

sp <- sp |>
  mutate(date = mdy(caldt)) |>
  arrange(date) |>
  rename(r_sp = vwretd)

head(sp)
names(sp)

# ===== Stock + daily rf data (CRSP-style long panel) =====
# File: lecture7p_2025.csv, columns: date (m/d/Y), ticker, ..., ret*, rf, ...
raw_daily <- read_csv("lecture7p_2025.csv", col_types = cols()) |>
  mutate(date = mdy(date)) |>
  arrange(date)

head(raw_daily)
names(raw_daily)

# ---- Choose which return column to use dynamically ----
# We look for columns that start with "ret" but are not "ret_excess".
ret_candidates <- names(raw_daily)[grepl("^ret", names(raw_daily)) & names(raw_daily) != "ret_excess"]

ret_candidates

if (length(ret_candidates) == 0) {
  stop(
    paste(
      "Could not find a usable return column in lecture7p_2025.csv.",
      "Available columns are:",
      paste(names(raw_daily), collapse = ", ")
    )
  )
}

# Use the first such return column
ret_col <- ret_candidates[1]
ret_col

# Pivot to wide by ticker using that return column
stock_daily_long <- raw_daily |>
  select(date, ticker, all_of(ret_col)) |>
  rename(ret = all_of(ret_col))

stock_daily_wide <- stock_daily_long |>
  mutate(ticker = as.character(ticker)) |>
  pivot_wider(names_from = ticker, values_from = ret)

# Extract rf series (one per date)
if (!("rf" %in% names(raw_daily))) {
  stop(
    paste(
      "Couldn't find a risk-free (rf) column in lecture7p_2025.csv.",
      "Available columns are:",
      paste(names(raw_daily), collapse = ", ")
    )
  )
}

rf_series <- raw_daily |>
  select(date, rf) |>
  distinct()

# Merge rf into the wide stock data
daily <- stock_daily_wide |>
  left_join(rf_series, by = "date") |>
  arrange(date)

head(daily)
names(daily)
```

---

## 1. Optimal allocation: S&P 500 vs bond (A = 4)

We treat the **bond** as investing at the **daily risk-free rate `rf`**.  
We match S&P dates with the risk-free rate, compute daily excess returns, then annualize.

```{r}
# Match S&P data with daily rf
sp_rf <- sp |>
  inner_join(daily |> select(date, rf), by = "date") |>
  mutate(
    r_bond   = rf,              # bond = risk-free asset
    r_excess = r_sp - r_bond
  )

# Annual mean and variance of excess returns
mu_e_daily  <- mean(sp_rf$r_excess, na.rm = TRUE)
var_e_daily <- var(sp_rf$r_excess,  na.rm = TRUE)

mu_e_annual  <- TRADING_DAYS * mu_e_daily
var_e_annual <- TRADING_DAYS * var_e_daily

A <- 4

w_stock <- mu_e_annual / (A * var_e_annual)
w_bond  <- 1 - w_stock

w_stock
w_bond
```

---

## 2. Weekly and annual statistics + correlation matrix

We form **weekly simple returns** for each stock and compute:

- weekly mean & standard deviation  
- annualized mean and SD  
- correlation matrix of weekly returns

```{r}
# Identify the five tickers of interest
tickers5 <- c("MSFT", "INTC", "LUV", "MCD", "JNJ")

# Sanity check: all tickers should exist as columns in 'daily'
missing_tickers <- setdiff(tickers5, names(daily))
missing_tickers  # should be character(0); if not, something is off with the tickers.

# 2.1 Construct weekly stock returns (simple compounding within each week)
weekly <- daily |>
  mutate(week = floor_date(date, unit = "week", week_start = 1)) |>
  group_by(week) |>
  summarize(
    across(all_of(tickers5),
           ~ prod(1 + .x, na.rm = TRUE) - 1),
    .groups = "drop"
  )

head(weekly)

# 2.2 Weekly mean & sd for each stock, plus annualized versions
weekly_stats <- weekly |>
  summarize(across(all_of(tickers5),
                   list(mean = ~ mean(.x, na.rm = TRUE),
                        sd   = ~ sd(.x,   na.rm = TRUE))))

weekly_stats_long <- weekly_stats |>
  pivot_longer(
    cols      = everything(),
    names_to  = c("stock", "stat"),
    names_sep = "_",
    values_to = "value"
  ) |>
  pivot_wider(names_from = stat, values_from = value) |>
  mutate(
    mean_ann = mean * WEEKS_PER_YEAR,
    sd_ann   = sd   * sqrt(WEEKS_PER_YEAR)
  )

weekly_stats_long
```

```{r}
# 2.3 Weekly correlation matrix
cor_weekly <- weekly |>
  select(-week) |>
  cor(use = "pairwise.complete.obs")

cor_weekly
```

---

## 3. Mean–variance frontier: Intel + Microsoft

We use **weekly** returns of MSFT & INTC, compute μ and Σ, and sweep weights in MSFT.

```{r}
# 3.1 Weekly returns for MSFT & INTC
weekly_IM <- weekly |>
  select(week, MSFT, INTC)

mu_IM <- colMeans(weekly_IM |> select(MSFT, INTC), na.rm = TRUE)
Sigma_IM <- cov(weekly_IM |> select(MSFT, INTC),
                use = "pairwise.complete.obs")

mu_IM
Sigma_IM
```

```{r}
# 3.2 Grid of portfolios using w_MSFT (w_INTC = 1 - w_MSFT)
w_grid <- seq(-0.5, 1.5, length.out = 400)

frontier_IM <- tibble(
  w_MSFT = w_grid,
  w_INTC = 1 - w_MSFT
) |>
  mutate(
    mean = w_MSFT * mu_IM["MSFT"] + w_INTC * mu_IM["INTC"],
    var  = w_MSFT^2 * Sigma_IM[1, 1] +
           w_INTC^2 * Sigma_IM[2, 2] +
           2 * w_MSFT * w_INTC * Sigma_IM[1, 2],
    sd   = sqrt(var)
  )

head(frontier_IM)
```

```{r}
# 3.3 Minimum-variance portfolio (closed form)
one2 <- c(1, 1)
Sigma_IM_inv <- solve(Sigma_IM)
A_IM <- as.numeric(t(one2) %*% Sigma_IM_inv %*% one2)
w_mv_IM <- as.vector(Sigma_IM_inv %*% one2 / A_IM)

names(w_mv_IM) <- c("MSFT", "INTC")
w_mv_IM

mu_mv_IM <- sum(w_mv_IM * mu_IM)
sd_mv_IM <- sqrt(as.numeric(t(w_mv_IM) %*% Sigma_IM %*% w_mv_IM))

mu_mv_IM
sd_mv_IM

# Mark efficient part (portfolios with mean >= min-variance mean)
frontier_IM <- frontier_IM |>
  mutate(efficient = mean >= mu_mv_IM)
```

```{r}
# 3.4 Plot MSFT–INTC frontier
ggplot(frontier_IM, aes(x = sd, y = mean)) +
  geom_line() +
  geom_line(data = subset(frontier_IM, efficient),
            linewidth = 1.1) +
  geom_point(aes(x = sd_mv_IM, y = mu_mv_IM),
             size = 3) +
  labs(
    x = "Portfolio weekly SD",
    y = "Portfolio weekly mean return",
    title = "Mean–Variance Frontier: MSFT & INTC"
  )
```

---

## 4. Mean–variance frontier: all 5 stocks vs MSFT+INTC

We now include **all five stocks** and compute the multi-asset efficient frontier using the usual A,B,C,D formulas.

```{r}
# 4.1 Covariance and means for all 5 stocks (weekly)
assets_all <- weekly |>
  select(week, all_of(tickers5))

mu_all <- colMeans(assets_all |> select(-week), na.rm = TRUE)
Sigma_all <- cov(assets_all |> select(-week),
                 use = "pairwise.complete.obs")

mu_all
Sigma_all
```

```{r}
# 4.2 Efficient frontier for 5 stocks
Sigma_all_inv <- solve(Sigma_all)
one5 <- rep(1, length(mu_all))

A_all <- as.numeric(t(one5) %*% Sigma_all_inv %*% one5)
B_all <- as.numeric(t(one5) %*% Sigma_all_inv %*% mu_all)
C_all <- as.numeric(t(mu_all) %*% Sigma_all_inv %*% mu_all)
D_all <- A_all * C_all - B_all^2

mu_min_all <- min(mu_all)
mu_max_all <- max(mu_all)

mu_target_all <- seq(mu_min_all * 0.8,
                     mu_max_all * 1.2,
                     length.out = 200)

frontier_all <- map_dfr(mu_target_all, function(mu_p) {
  lambda1 <- (C_all - B_all * mu_p) / D_all
  lambda2 <- (A_all * mu_p - B_all) / D_all
  w <- Sigma_all_inv %*% (lambda1 * one5 + lambda2 * mu_all)
  tibble(
    mean = mu_p,
    sd   = sqrt(as.numeric(t(w) %*% Sigma_all %*% w))
  )
})

# Minimum-variance portfolio for all 5
w_mv_all <- as.vector(Sigma_all_inv %*% one5 / A_all)
names(w_mv_all) <- names(mu_all)
w_mv_all

mu_mv_all <- sum(w_mv_all * mu_all)
sd_mv_all <- sqrt(as.numeric(t(w_mv_all) %*% Sigma_all %*% w_mv_all))

mu_mv_all
sd_mv_all

frontier_all <- frontier_all |>
  mutate(efficient = mean >= mu_mv_all)
```

```{r}
# 4.3 Plot MSFT+INTC frontier vs all-5 frontier
frontier_IM_plot <- frontier_IM |>
  transmute(mean, sd, efficient_IM = efficient)

ggplot() +
  # 2-asset frontier (MSFT+INTC)
  geom_line(data = frontier_IM_plot,
            aes(x = sd, y = mean),
            linetype = "dashed") +
  geom_line(data = subset(frontier_IM_plot, efficient_IM),
            aes(x = sd, y = mean)) +
  geom_point(aes(x = sd_mv_IM,  y = mu_mv_IM),
             size = 3) +
  # 5-asset frontier
  geom_line(data = frontier_all,
            aes(x = sd, y = mean)) +
  geom_line(data = subset(frontier_all, efficient),
            aes(x = sd, y = mean),
            linewidth = 1.1) +
  geom_point(aes(x = sd_mv_all, y = mu_mv_all),
             size = 3, shape = 17) +
  labs(
    x = "Portfolio weekly SD",
    y = "Portfolio weekly mean return",
    title = "Mean–Variance Frontier: MSFT+INTC vs All 5 Stocks"
  )
```

---

## 5. Tangent portfolios (with risk-free asset)

Now we incorporate the **weekly risk-free rate** and compute the **maximum-Sharpe (tangent) portfolios** for:

- MSFT + INTC only  
- All 5 stocks  

```{r}
# 5.1 Weekly risk-free returns from daily rf
weekly_rf <- daily |>
  select(date, rf) |>
  mutate(week = floor_date(date, unit = "week", week_start = 1)) |>
  group_by(week) |>
  summarize(
    rf_week = prod(1 + rf, na.rm = TRUE) - 1,
    .groups = "drop"
  )

# Combine weekly stock returns with weekly rf
weekly_full <- weekly |>
  inner_join(weekly_rf, by = "week")

head(weekly_full)
```

```{r}
# 5.2 Tangent portfolio for MSFT + INTC

IM_data <- weekly_full |>
  select(MSFT, INTC, rf_week)

mu_IM <- colMeans(IM_data[, c("MSFT", "INTC")], na.rm = TRUE)
Sigma_IM <- cov(IM_data[, c("MSFT", "INTC")],
                use = "pairwise.complete.obs")

rf_bar <- mean(IM_data$rf_week, na.rm = TRUE)  # avg weekly rf

Sigma_IM_inv <- solve(Sigma_IM)
excess_mu_IM <- mu_IM - rf_bar

w_t_IM_unnorm <- Sigma_IM_inv %*% excess_mu_IM
w_t_IM <- as.vector(w_t_IM_unnorm / sum(w_t_IM_unnorm))
names(w_t_IM) <- c("MSFT", "INTC")

w_t_IM

mu_T_IM <- sum(w_t_IM * mu_IM)
sd_T_IM <- sqrt(as.numeric(t(w_t_IM) %*% Sigma_IM %*% w_t_IM))
Sharpe_IM <- (mu_T_IM - rf_bar) / sd_T_IM

mu_T_IM
sd_T_IM
Sharpe_IM
```

```{r}
# 5.3 Tangent portfolio for all 5 stocks

mu_all <- colMeans(weekly_full[, tickers5],
                   na.rm = TRUE)
Sigma_all <- cov(weekly_full[, tickers5],
                 use = "pairwise.complete.obs")

Sigma_all_inv <- solve(Sigma_all)
one5 <- rep(1, length(mu_all))

excess_mu_all <- mu_all - rf_bar

w_t_all_unnorm <- Sigma_all_inv %*% excess_mu_all
w_t_all <- as.vector(w_t_all_unnorm / sum(w_t_all_unnorm))
names(w_t_all) <- names(mu_all)

w_t_all

mu_T_all <- sum(w_t_all * mu_all)
sd_T_all <- sqrt(as.numeric(t(w_t_all) %*% Sigma_all %*% w_t_all))
Sharpe_all <- (mu_T_all - rf_bar) / sd_T_all

mu_T_all
sd_T_all
Sharpe_all
```

---

## 6. Optimal overall mix given risk aversion A = 3.5

We now assume **risk aversion A = 3.5** and use the **all-5-stock tangent portfolio**.

For a mean–variance investor with a risk-free asset and a tangent portfolio, the optimal fraction of wealth invested in the tangent portfolio (call it `y_star`) is:

- proportional to the Sharpe ratio of the tangent portfolio, and  
- inversely proportional to both risk aversion `A_opt` and the variance `sd_T_all^2`.

We compute it directly below, then back out the weights.

```{r}
A_opt <- 3.5

y_star <- (mu_T_all - rf_bar) / (A_opt * sd_T_all^2)
y_star
```

```{r}
# Weights in risky stocks
w_risky_opt <- y_star * w_t_all
w_risky_opt

# Weight in the risk-free asset
w_rf_opt <- 1 - y_star
w_rf_opt
```

```{r}
# Sanity check: total weight in all assets (risky + rf)
sum(w_risky_opt) + w_rf_opt
```
