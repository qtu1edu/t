# -*- coding: utf-8 -*-
"""NM for Logistic Growth Model

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-Wx57O8nqXJ5qMsX-QJiapv9bRaSHr7h
"""

#Question 1
import numpy as np
import matplotlib.pyplot as pl
# Author: Qianxun Tu
# Date: 6/5/24

'''
This is a computation for Euler, Heun, and RK4 methods for numerical algorithms,
solving the logistic growth model in population dynamics.
It compares their accuracy in different step sizes.
'''

# Define constants for the logistic growth model
r = 0.06 # Growth rate
K = 2000 # Carrying capacity (maximum population)
P0 = 1200 # Initial population
t_max = 30 # Time period for simulation (in years)

# Function defining the logistic growth model
def dP_dt(t, P):
    return r * P * (1 - P / K)
# Euler Method for numerical approximation
def euler_method(h):

    t_values = np.arange(0, t_max + h, h)
    P_values = np.zeros(t_values.shape)
    P_values[0] = P0
    for i in range(1, len(t_values)):
        P_values[i] = P_values[i-1] + h * dP_dt(t_values[i-1], P_values[i-1])
    return t_values, P_values

# Heun's Method (Improved Euler Method)
def heun_method(h):
    t_values = np.arange(0, t_max + h, h)
    P_values = np.zeros(t_values.shape)
    P_values[0] = P0
    for i in range(1, len(t_values)):
        P_predict = P_values[i-1] + h * dP_dt(t_values[i-1], P_values[i-1])
        P_values[i] = P_values[i-1] + h/2 * (dP_dt(t_values[i-1], P_values[i-1]) + dP_dt(t_values[i], P_predict))
    return t_values, P_values

# Runge-Kutta 4th Order Method
def rk4_method(h):
    t_values = np.arange(0, t_max + h, h)
    P_values = np.zeros(t_values.shape)
    P_values[0] = P0
    for i in range(1, len(t_values)):
        t = t_values[i-1]
        P = P_values[i-1]
        k1 = h * dP_dt(t, P)
        k2 = h * dP_dt(t + h/2, P + k1/2)
        k3 = h * dP_dt(t + h/2, P + k2/2)
        k4 = h * dP_dt(t + h, P + k3)
        P_values[i] = P + (k1 + 2*k2 + 2*k3 + k4) / 6
    return t_values, P_values

# Different step sizes to compare accuracy
step_sizes = [10, 1, 0.1]

# Create subplots for each method and step size
fig, axes = plt.subplots(3, 3, figsize=(18, 18))

# Plot Euler method results
for i, h in enumerate(step_sizes):
    t_euler, P_euler = euler_method(h)
    axes[0, i].plot(t_euler, P_euler, label=f'Euler Method (h={h})')
    axes[0, i].set_title(f'Euler Method (h={h})')
    axes[0, i].set_xlabel('Time (years)')
    axes[0, i].set_ylabel('Population')
    axes[0, i].legend()

# Plot Heun's method results
for i, h in enumerate(step_sizes):
    t_heun, P_heun = heun_method(h)
    axes[1, i].plot(t_heun, P_heun, label=f'Heun\'s Method (h={h})')
    axes[1, i].set_title(f'Heun\'s Method (h={h})')
    axes[1, i].set_xlabel('Time (years)')
    axes[1, i].set_ylabel('Population')
    axes[1, i].legend()

# Plot RK4 method results
for i, h in enumerate(step_sizes):
    t_rk4, P_rk4 = rk4_method(h)
    axes[2, i].plot(t_rk4, P_rk4, label=f'RK4 Method (h={h})')
    axes[2, i].set_title(f'RK4 Method (h={h})')
    axes[2, i].set_xlabel('Time (years)')
    axes[2, i].set_ylabel('Population')
    axes[2, i].legend()

plt.tight_layout()
plt.show()

#Question 2
#Continuing second-order differential equation.

import numpy as np
import matplotlib.pyplot as plt
from scipy.special import gamma

#Initial condition
y0 = 0.6652
dy0 = 0.33627

# Function defining the system of first-order ODEs
def f(x, y):
    y1, y2 = y
    dy1_dx = y2
    dy2_dx = -x * y1 / 3
    return np.array([dy1_dx, dy2_dx])

# Euler Method for numerical approximation
def euler_method(f, y0, x0, x_max, h):
    x_values = np.arange(x0, x_max + h, h)
    y_values = np.zeros((len(x_values), 2))
    y_values[0] = y0
    for i in range(1, len(x_values)):
        y_values[i] = y_values[i-1] + h * f(x_values[i-1], y_values[i-1])
    return x_values, y_values[:, 0]

# Heun's Method (Improved Euler Method)
def heun_method(f, y0, x0, x_max, h):
    x_values = np.arange(x0, x_max + h, h)
    y_values = np.zeros((len(x_values), 2))
    y_values[0] = y0
    for i in range(1, len(x_values)):
        y_pred = y_values[i-1] + h * f(x_values[i-1], y_values[i-1])
        y_values[i] = y_values[i-1] + h/2 * (f(x_values[i-1], y_values[i-1]) + f(x_values[i], y_pred))
    return x_values, y_values[:, 0]

# Runge-Kutta 4th Order Method
def rk4_method(f, y0, x0, x_max, h):
    x_values = np.arange(x0, x_max + h, h)
    y_values = np.zeros((len(x_values), 2))
    y_values[0] = y0
    for i in range(1, len(x_values)):
        k1 = h * f(x_values[i-1], y_values[i-1])
        k2 = h * f(x_values[i-1] + h/2, y_values[i-1] + k1/2)
        k3 = h * f(x_values[i-1] + h/2, y_values[i-1] + k2/2)
        k4 = h * f(x_values[i-1] + h, y_values[i-1] + k3)
        y_values[i] = y_values[i-1] + (k1 + 2*k2 + 2*k3 + k4) / 6
    return x_values, y_values[:, 0]

y0_values = [y0, dy0]

# Different step sizes to compare accuracy
step_sizes = [1, 0.1, 0.01, 0.001]

# Create subplots for each method and step size
fig, axes = plt.subplots(3, 4, figsize=(24, 18))

methods = {
    'Euler': euler_method,
    'Heun': heun_method,
    'RK4': rk4_method
}

# Plot results for each method and step size
for j, (method_name, method) in enumerate(methods.items()):
    for i, h in enumerate(step_sizes):
        x_values, y_values = method(f, y0_values, 0, 10, h)
        axes[j, i].plot(x_values, y_values, label=f'{method_name} Method (h={h})')
        axes[j, i].set_title(f'{method_name} Method (h={h})')
        axes[j, i].set_xlabel('x')
        axes[j, i].set_ylabel('y')
        axes[j, i].legend()

plt.tight_layout()
plt.show()
